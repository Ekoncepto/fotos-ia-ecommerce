# Technical Debt: Lack of Server-Side Idempotency for Credit Consumption

## Issue

The API endpoint for credit consumption, `/api/generate-image`, is not idempotent. This means that if the same request is sent multiple times, it will be processed multiple times, leading to multiple credit deductions for a single intended action. This was identified as a high-severity issue (`TECH-002`) in the QA review.

While the client-side logic has been improved to prevent accidental double-clicks by the user, this does not protect against other scenarios, such as:
-   **Network Retries:** A client or an intermediary proxy might automatically retry a request if it doesn't receive a timely response, even if the server has already processed the original request.
-   **Malicious Actions:** A malicious user could intentionally replay a request to consume credits or cause other unintended side effects.

## Risks

-   **Unfair Credit Deduction:** Users can be charged multiple times for a single image generation, leading to a poor user experience and loss of trust.
-   **Data Inconsistency:** The state of the system could become inconsistent if the same action is performed multiple times.
-   **Customer Support Overhead:** This issue is likely to generate customer support requests from users who have been incorrectly charged.

## Blocker for Immediate Implementation

A robust, server-side idempotency mechanism requires a persistent store to keep track of processed request keys. The standard way to implement this is by creating a new database table (e.g., `idempotency_keys`).

As the `dev` agent, I am currently blocked from making database schema changes, as this is considered an architectural decision that should be handled through the project's defined database migration process (which seems to be managed via the Supabase dashboard).

## Recommended Solution

When this technical debt is prioritized, the following server-side solution should be implemented:

1.  **Database Schema Change:**
    -   Create a new table in the Supabase database named `idempotency_keys`.
    -   **Columns:**
        -   `key` (TEXT, PRIMARY KEY): The unique idempotency key generated by the client.
        -   `user_id` (UUID, FOREIGN KEY to `users.id`): The ID of the user who made the request.
        -   `created_at` (TIMESTAMPTZ): The timestamp of the first time the request was processed.

2.  **Supabase RPC Function:**
    -   Create a new database function (RPC) named `generate_image_idempotent`.
    -   **Arguments:** `user_id`, `idempotency_key`, `cost`.
    -   **Logic (in a single transaction):**
        1.  Attempt to insert the `idempotency_key` and `user_id` into the `idempotency_keys` table.
        2.  If the insert fails due to a primary key violation (meaning the key has been processed before), return a success status without taking any further action.
        3.  If the insert succeeds, proceed to check the user's credit balance.
        4.  If the user has insufficient credits, rollback the transaction and return an error.
        5.  If the user has sufficient credits, deduct the `cost` from the `user_credits` table.
        6.  Commit the transaction and return a success status with the new credit balance.

3.  **Client and API Changes:**
    -   The client (`apps/web/components/image-generator.tsx`) should be updated to generate a unique idempotency key (e.g., using the `uuid` library) for each image generation request and send it in a custom header (e.g., `X-Idempotency-Key`).
    -   The API route (`apps/web/app/api/generate-image/route.ts`) should be updated to call the new `generate_image_idempotent` RPC function instead of performing the logic itself.

## Next Steps

1.  The **Product Owner** or **Architect** should review this technical debt and prioritize it in the backlog.
2.  Once prioritized, the necessary database schema changes (new table) and the new RPC function should be created.
3.  A new story should be created for the `dev` agent to implement the client and API changes to use the new idempotency mechanism.
