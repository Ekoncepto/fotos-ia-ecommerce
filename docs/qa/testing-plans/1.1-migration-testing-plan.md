# Testing Plan: Automated Database Migrations (Story 1.1)

This document provides a step-by-step guide for testing the automated database migration process in a staging environment.

## Prerequisites

- A staging environment that is a close replica of the production environment.
- Access to the staging database to verify schema changes.
- A CI/CD pipeline that automatically deploys to the staging environment on commits to the staging branch.
- A new branch created from the staging branch for testing purposes.

## Test Case 1: Successful Migration

**Objective:** Verify that a valid database migration is applied automatically and successfully during deployment.

**Steps:**

1.  **Create a new migration file:**
    -   In your local development environment, on the new testing branch, create a new Supabase migration file.
    -   The migration should contain a simple, non-breaking change. For example, adding a new column to the `user_credits` table:
        ```sql
        ALTER TABLE public.user_credits ADD COLUMN last_updated_at timestamptz DEFAULT now();
        ```
2.  **Commit and push the migration:**
    -   Commit the new migration file to your testing branch.
    -   Create a pull request to merge the testing branch into the staging branch.
3.  **Deploy to staging:**
    -   Merge the pull request to trigger a deployment to the staging environment.
4.  **Verify the deployment:**
    -   Monitor the deployment logs in Netlify (or your CI/CD provider).
    -   Ensure that the `npm run migrate` command runs successfully and that the deployment completes without errors.
5.  **Verify the database schema:**
    -   Connect to your staging database.
    -   Check the `user_credits` table to confirm that the `last_updated_at` column has been added.
6.  **Smoke test the application:**
    -   Access the staging application in your browser.
    -   Perform a quick smoke test to ensure that the main functionalities (login, viewing credits, etc.) are still working as expected.

## Test Case 2: Failing Migration

**Objective:** Verify that a failing migration causes the deployment to fail and leaves the database in a consistent state.

**Steps:**

1.  **Create a failing migration file:**
    -   On a new testing branch, create a new migration file with an invalid SQL statement or a change that will cause an error. For example, adding a `NOT NULL` column to a table with existing rows without providing a default value:
        ```sql
        ALTER TABLE public.user_credits ADD COLUMN new_col text NOT NULL;
        ```
2.  **Commit and push the migration:**
    -   Commit the failing migration file to your testing branch.
    -   Create a pull request to merge the testing branch into the staging branch.
3.  **Deploy to staging:**
    -   Merge the pull request to trigger a deployment to the staging environment.
4.  **Verify the deployment failure:**
    -   Monitor the deployment logs.
    -   Verify that the `npm run migrate` command fails and that the deployment is marked as failed.
5.  **Verify the database state:**
    -   Connect to your staging database.
    -   Check the `user_credits` table to confirm that the `new_col` column has **not** been added.
    -   The database schema should be in the same state as before the failed deployment.
6.  **Verify the application:**
    -   Access the staging application.
    -   Verify that the application is still running with the previous version of the code and is fully functional.

## Test Case 3: Application Compatibility

**Objective:** Verify that the application remains compatible with the database schema after a successful migration.

**Steps:**

1.  **Perform a successful migration:**
    -   Follow the steps in Test Case 1 to deploy a successful migration.
2.  **Perform thorough testing:**
    -   After the deployment is complete, perform a more comprehensive set of tests on the staging application.
    -   Focus on the features that interact with the modified database table (`user_credits` in this example).
    -   For example, test the credit deduction functionality to ensure that it still works correctly with the new column.

By executing these test cases, you can gain confidence that the automated database migration process is working correctly and is resilient to failures.